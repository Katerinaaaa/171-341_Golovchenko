// lab_7.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream> 


//все переменные которые создаются внутри функций выделяются в стэковой памяти (stak overflow) 
//стэковая память ограничена, при неправильном использовании стэк переполняется 
// размерности массивов, выделяемых в стековой памяти, фиксированы и задаются константами

using namespace std; 

void fnc1() // функция для переполнения стека 
{
	int b[1000][1000] = { 0 };
	b[1][1] = 0; 
	cout << "Stack overflow" << endl; 
	return; 
} 


int main()
{


   	int l1 = 10, l2 = 15; 
	// int arr[l1][l2] = { 0 }; - в таком объявлении только константы 

	// стековая память ограничена, при неправильном использовании стек переполняется (stack overflow) 
	// размерности массивов, выделяемых в стековой памяти, фиксированы и задаются константами 
	// int b[1000][1000] = { 0 }; - вызывает переполнение стека 

	// для использования свободной нераспределенной памяти ОС (heap - "куча") 
	// объявляются динамические перемменные по синтаксису 
	// указатель_на_тип имя_переменной = new тип; 
	// или 
	// тип * имя_переменной = new тип; 
	// работа с динамической памятью происходит через указатели 

	// Преимущества 
	// 1) доступно гораздо больше памяти, нежелив стеке 
	// 2) размер массивов и структур данных можно определять и менять во время работы приложения 
	// Особенность: 
	// если программа предназначена для длительной работы, 
	// во избежание переполнения памяти созданные переменне и блоки памяти после использования 
	// должны быть освобождены с помощью оператора delete: 
	// delete имя_переменной; 

	int * ptr_int = new int; // в нераспределенной памяти создается блок, 
	// размером с int и указатель на него возвращается в переменную 

	// вызов утечки памяти 
	for (int i = 0; i < 10000; i++)
	{

		// 1) каждый заход в стеке создается новый указатель 
		// 2)выделяется блок new long long;  в куче (нераспределенной памяти), приписанный к этой программе 
		// 3) стековая переменая b исчезает 
		// 4) а блок попрежнему остается там же 
		// 5) при следующем заходе выделяется новый блок 

		long long * b = new long long; 

		//совершать нужные действия с переменной 
		delete b; // удалять блок памяти, пока не потерян указатель на неё 
	}

	// пара оепраторов new/delete - это одно из нововведений C++ относительно С 

	// в динамической памяти могут выделяться только одномерные массивы 
	// тип * имя_указателя = new тип [данные]; 
	// удаляются отноменые массивы с помощью записи 
	// delete[] имя_указателя; 

	for (int i = 0; i < l1; i++) 
	{
		// для выделения двумерного массива сначала создается одномерный массив, содержащий указатели на другие массивы (строки) 
		
		// МОЖЕМ ЗАДАВАТЬ РАЗМЕРНОСТИ ПЕРЕМЕННЫМИ 
		
		int ** dynamic2Darray = new int *[l1];
		// затем выделяется блок памяти под каждую строку и указатель на неё возвращается в всозданный массив указателей 
		for (int i = 0; i < l1; i++)
		{
			dynamic2Darray[i] = new int[l2]; // dynamic2Darray[i] имеет тип int* 
			for (int j = 0; j < l2; j++)
			{
				dynamic2Darray[i][j] = i; 
			}
		}

		// освобождается массив в обратном порядке 

		for (int i = 0; i < l1; i++)
		{
			delete[] dynamic2Darray[i]; // dynamic2Darray[i] имеет тип int* 
		}
		delete[] dynamic2Darray;
	}

	// многомерные массивы фиксированной длины в стековой памяти чаще всего размещаются сплошным блоком 
	// динамические - нет (где ОС выделила место под очередную строку, там она и будет находиться, 
	// и между строками будет неизвестно, что) 

	int fixed_array[3][3] = { {10, 20, 30}, 
							{40, 50, 60},
							{70, 80, 90} }; 

	cout << endl;
	cout << "ARRAY IN DYNAMIC MEMORY:" << endl; 
	cout << "*** dynamic2Darray[0] ***" << endl; 
	cout << "Adress" << '\t\t\t' << "Value" << endl; 
	cout << "-----------------------------" << endl; 

	for (int * pointer  = &fixed_array[0][0] - 4; 
		pointer < &fixed_array[0][0] + 8;
		pointer++)
	{
		//cout << /*указатель*/ << '\t' << /*значение*/ << endl; 
		cout << "0x" << pointer << '\t' << *pointer << endl; 
	}

	getchar();


	return 0; 

}


