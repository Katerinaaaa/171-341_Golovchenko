// lab_6.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream> 

/* ЛАБОРАТОРНАЯ РАБОТА № 6*/ // лабораторная работа № 4 (NEW)

// Задачи: 
// 1) сложение матриц
// 2) сложение векторов 
// 3) умножение матриц 
// 4) умножение матрицы на вектор  
// 5) скалярное умножение векторов 
// 6) векторное умножение векторов 
// 7) вывод матрицы с помощью функций 
// реализовать программно 




int matrix1[3][3] = { { 1, 2, 3 },
{ 4, 5, 6 },				// объявление матрицы (1) 
{ 7, 8, 9 } };

int matrix2[3][3] = { { 1, 2, 3 },
{ 4, 5, 6 },			// объявление матрицы (2) 
{ 7, 8, 9 } };


int matrix_result[3][3] = { { 0, 0, 0 },
{ 0, 0, 0 },			// объявление результирующей матрицы 
{ 0, 0, 0 } };

int vector1[1][3] = { 1, 2, 3 }; // объявление вектора (1) 

int vector2[1][3] = { 1, 2, 3 }; // объявление вектора (2) 


int vector_result[1][3] = { 0, 0, 0 }; // объявлние результирующего вектора 

int scalar_mult = 0; // объявление переменной (в нее будет записан результат скалярного произведения) 


void summ_matrix(int(&matrix_result)[3][3], int const matrix1[3][3], int const matrix2[3][3]) // функция для подсчета суммы матриц 
{
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			matrix_result[i][j] = matrix1[i][j] + matrix2[i][j]; // формула сложения матриц
		}

	}
}
void summ_vector(int(&vector_result)[1][3], int const vector1[1][3], int const vector2[1][3]) // функция для подсчета суммы векторов 
{
	for (int i = 0; i < 3; i++)
	{
		vector_result[0][i] = 0;
		vector_result[0][i] = vector1[0][i] + vector2[0][i];  // формула сложения векторов 
	}
}

void mult_matrix(int(&matrix_result)[3][3], int const matrix1[3][3], int const matrix2[3][3]) // функция для умножения матриц 
{

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			matrix_result[i][j] = 0;
			for (int k = 0; k < 3; k++)
			{
				matrix_result[i][j] = matrix_result[i][j] + matrix1[i][k] * matrix2[k][j]; // формула умножения матриц 
			}
		}
	}
}

void matrix_mult_vector(int(&vector_result)[1][3], int const (*matrix1)[3], int const vector1[1][3]) // функция для умножения матрицы на вектор 
{

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++) {
			vector_result[i][j] = 0;
		}
	}
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			vector_result[0][i] = vector_result[0][i] + matrix1[i][j] * vector1[0][j]; // формула умножения матрицы на вектор 
		}
	}
}

void scalar_mult_vector(int(&scalar_mult), int vector1[1][3], int vector2[1][3]) // функция для скалярного умножения векторов 
{
	for (int j = 0; j < 3; j++)
	{
		scalar_mult = scalar_mult + vector1[0][j] * vector2[0][j]; // формула скалярного умножения векторов 
	}
}

void vector_mult_vector(int(&vector_result)[1][3], int const vector1[1][3], int const vector2[1][3]) // функция для векторного умноения векторов 
{

	for (int i = 0; i < 3; i++) {		// векторное умножение векторов 
		if (i == 0) {
			for (int j = 0; j < 3; j++) {
				matrix_result[i][j] = 1;
			}

		}
		else {
			if (i == 1) {
				for (int j = 0; j < 3; j++) {
					matrix_result[i][j] = vector1[0][j];
				}
			}
			else {
				for (int j = 0; j < 3; j++) {
					matrix_result[i][j] = vector2[0][j];
				}
			}
		}
	}

	for (int i = 0; i < 3; i++) {
		vector_result[0][i] = 0;
	}
	for (int i = 2; i > -1; i--)
	{
		(i == 0) ?
			(vector_result[0][i] = matrix_result[1][(i + 1) / 3] * matrix_result[2][i + 1] - matrix_result[1][i + 1] * matrix_result[2][(i + 1) / 3])
			:
			(vector_result[0][i] = matrix_result[1][(i + 1) / 3] * matrix_result[2][2] - matrix_result[1][2] * matrix_result[2][(i + 1) / 3]);
	}

}


void vivodMatrix(int matrix_result[3][3]) // функция для вывода результирующей матрицы 
{
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			std::cout << matrix_result[i][j] << "\t"; // вывод результирующей матрицы 
		}
		std::cout << std::endl;
	}
	std::cout << std::endl;
}


void vivodVector(int vector_result[1][3]) // функция для вывода результирующего вектора 
{
	std::cout << std::endl;
	for (int i = 0; i < 3; i++)
	{
		std::cout << vector_result[0][i] << '\t'; // вывод результирующего вектора 
	}
	std::cout << std::endl;
	std::cout << std::endl;
}



int main()
{

	summ_matrix(matrix_result, matrix1, matrix2); // вызов функции для суммы матриц 
	vivodMatrix(matrix_result); // вызов функции для вывода результирующей 

	summ_vector(vector_result, vector1, vector2);  // вызов функции для суммы векторов 
	vivodVector(vector_result); // вызов функции для вывода результирующего вектора  


	mult_matrix(matrix_result, matrix1, matrix2); // вызов функции для произведения матриц 
	vivodMatrix(matrix_result); // вызов функции для вывода результирующей матрицы 


	matrix_mult_vector(vector_result, matrix1, vector1); // вызов функции для произведения матрицы на вектор 
	vivodVector(vector_result); // вызов функции для вывода результирующего вектора 



	scalar_mult_vector(scalar_mult, vector1, vector2); // вызов функции для скалярного произведения векторов 
	std::cout << scalar_mult << std::endl; // вызов функции для вывода скалярного произведения 



	vector_mult_vector(vector_result, vector1, vector2); // вызов функции для векторного произведения векторов 
	vivodVector(vector_result); // вызов функции для вывода результирующего вектора 

	getchar();

	return 0;
}
// GIT - это система управления версиями файлов.Физически представляет из себя консольное приложение со своей системой команд.Позволяет: 
// 1. создавать снимки текущего состояния файлов (версии)
// 2. откатываться к предыдущим версиям, сливать версии вместе 
// 3. позволяет работать с удаленным хранилищем (репозиторием) 
// 4. является удобным средством командной работы 
// GIT в первую очередь нацелен на эффективную работу с не заархивинованными текстовыми файлами (не сжатыми) 
// в этом случае GIT фиксирует изменения, определяет различия текущей и предыдущей версий вплоть до отдельных строк или символов 
// и найденные изменения, различия записываются в новом снимке 
// это способствует экономии дискового пространства при хранении множества версий 

/*
ОСНОВЫ РАБОТЫ С GIT

1) Начало работы - инициализация репозитория:

CD <папка *.sln решения>
git init

cd: - change directory (на уровень выше)

главная ветка проекта называется master

появляется скрытая папка .git, где и будет хранться история изменений и настройки

2) по умолчанию git будет фиксировать историю файлов кода с известными расширениями:
txt, cpp, h, hpp, hxx, c
py, xml, html
однако в репозиторий также требуется включать и файлы проектов и решений
которые git сам не учитывает
для этого нужно воспользоваться командой

git add <имя_файла>

достаточо добавить учёт файла в репозитории 1 раз
категорически не следует добавлять исполняемые файлы,
временные и автоматически генерируемые файлы:
*.exe, *.lib, *.dll, *.pch, *.ipch, *.db, *.pdb и др.
не слеудет добавлять целиком папки /x86, /x64, /release, /debug.

3) зафиксировать версию (снимок) группы файлов

git commit -m"Комментарий к версии"

Ввод комментария строго обязателен.

4) для синхронизации с удалённым репозиторием
нужно
-закоммитить изменения в локальном
-прописать адрес удалённого

git remote add <краткий_псевдоним> <ссылка>

5) в любой момент можно посмотреть статус репозитория через

git status

6) получить справку по любой команде

git <имя_команды> --help

7) после переименования файла нужно:

1. git add <новое имя>
2. !!! в некоторых случаях, когда git status выдаёт missing: <старое_имя_файла>
git delete -cached <старое_имя_файла>

8) для любителей графических решений можно использовть TortoiseGit -
расширение проводника Windoes, добавляющее контекстные команды для управления репозиториями


9) СОЗДАЁТСЯ КОПИЯ УДАЛЁННОГО РЕПОЗИТОРИЯ КОМАНДОЙ  GIT CLONE И http:// ... 
		1) в начале пары -  GIT CLONE 
		2) в ходе лабораторной работы с кодом 
		3) после работы фиксация изменений git commit и заливка на удаленный git push 
*/